---
// Dynamic route for individual play-and-watch holidays
export const prerender = true;

import HolidayDetail from '../../components/HolidayDetail.astro';
import { getPlayAndWatchHolidays, getPlayAndWatchBySlug, getPlayAndWatchNestedData, getPlayAndWatchSEO, getEventsByUniqueValue, getTennisHolidays, getProductReviews } from '../../utils/strapi.js';

// Generate static paths for all play-and-watch holidays
export async function getStaticPaths() {
  const playAndWatchHolidays = await getPlayAndWatchHolidays(1, 100);
  
  return playAndWatchHolidays.map((holiday) => ({
    params: { slug: holiday.slug },
    props: { 
      slug: holiday.slug,
      id: holiday.strapiId,
      documentId: holiday.documentId
    }
  }));
}

const { slug } = Astro.params;
const { id, documentId } = Astro.props;
const fallbackIdentifiers = { id, documentId };
console.log(`üéæ [${slug}] Static props identifiers:`, fallbackIdentifiers);

// Fetch the specific play-and-watch holiday data
let holidayData = null;
try {
  holidayData = await getPlayAndWatchBySlug(slug, fallbackIdentifiers);
  if (holidayData) {
    console.log(`üéæ [${slug}] Play-and-watch holiday data fetched successfully`);
  } else {
    console.warn(`üéæ [${slug}] Play-and-watch holiday data not found after lookup`);
  }
} catch (error) {
  console.error(`[${slug}] Error fetching play-and-watch holiday:`, error.message);
}

// If no data found, show 404
if (!holidayData) {
  return Astro.redirect('/404');
}

// SEPARATE API CALL: Fetch nested data (rooms.roomGallery, tripImages)
// This is required for Strapi v5's nested population
try {
  const nestedData = await getPlayAndWatchNestedData(slug);
  if (nestedData) {
    // Merge nested data into holidayData
    if (nestedData.rooms && nestedData.rooms.length > 0) {
      holidayData.rooms = nestedData.rooms;
    }
    if (nestedData.tripImages && nestedData.tripImages.length > 0) {
      holidayData.tripImages = nestedData.tripImages;
    }
    console.log(`üè® [${slug}] Nested data merged: ${nestedData.rooms?.length || 0} rooms, ${nestedData.tripImages?.length || 0} trip images`);
  }
} catch (error) {
  console.error(`[${slug}] Error fetching nested data:`, error.message);
}

// SEPARATE API CALL: Fetch SEO data with metaImage
// This is required for Strapi v5's nested population of seo.metaImage
try {
  const seoData = await getPlayAndWatchSEO(slug);
  if (seoData) {
    // Merge SEO data into holidayData
    holidayData.seo = seoData;
    console.log(`üìÑ [${slug}] SEO data merged: ${seoData.metaTitle || 'No title'}, metaImage: ${seoData.metaImage ? 'Yes' : 'No'}`);
  }
} catch (error) {
  console.error(`[${slug}] Error fetching SEO data:`, error.message);
}

// Fetch random other destinations (play-and-watch + tennis holidays, excluding current one)
let similarHolidays = [];
try {
  const [playAndWatchHolidays, tennisHolidays] = await Promise.all([
    getPlayAndWatchHolidays(1, 50),
    getTennisHolidays(1, 50)
  ]);
  
  // Combine both types and filter: exclude current holiday AND only show those with displayOnFrontEnd = true
  const combinedHolidays = [...playAndWatchHolidays, ...tennisHolidays];
  const otherHolidays = combinedHolidays.filter(h => 
    h.slug !== slug && h.displayOnFrontEnd === true
  );
  
  // Randomize and select 3 destinations
  if (otherHolidays.length > 0) {
    const shuffled = [...otherHolidays];
    for (let i = shuffled.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    similarHolidays = shuffled.slice(0, 3);
    console.log(`üé≤ Selected ${similarHolidays.length} destinations (play-and-watch + tennis) from ${otherHolidays.length} available`);
  }
} catch (error) {
  console.error('Error fetching other destinations:', error);
}

// Fetch events matching this play-and-watch holiday's uniqueValue
let matchingEvents = [];
try {
  if (holidayData.uniqueValue) {
    console.log(`üéæ Fetching events for play-and-watch holiday uniqueValue: "${holidayData.uniqueValue}"`);
    matchingEvents = await getEventsByUniqueValue(holidayData.uniqueValue);
    console.log(`üéæ Found ${matchingEvents.length} matching event(s)`);
  } else {
    console.warn(`‚ö†Ô∏è Play-and-watch holiday "${slug}" has no uniqueValue set`);
  }
} catch (error) {
  console.error('Error fetching events for play-and-watch holiday:', error);
}

// Fetch product reviews if uniqueValue exists
let productReviews = [];
try {
  if (holidayData.uniqueValue) {
    console.log(`‚≠ê Debug - Attempting to fetch reviews for uniqueValue: "${holidayData.uniqueValue}"`);
    productReviews = await getProductReviews(holidayData.uniqueValue);
    console.log(`‚≠ê Debug - Fetched reviews count: ${productReviews.length}`);
    
    if (productReviews.length > 0) {
      holidayData.productReviews = productReviews;
      console.log(`‚≠ê [${slug}] Found ${productReviews.length} reviews matching uniqueValue "${holidayData.uniqueValue}"`);
    } else {
      console.log(`‚≠ê [${slug}] No reviews found for uniqueValue "${holidayData.uniqueValue}"`);
    }
  } else {
    console.log(`‚≠ê Debug - Skipping review fetch because uniqueValue is missing`);
  }
} catch (error) {
  console.error('Error fetching reviews:', error);
}
---

<HolidayDetail 
  holidayData={holidayData}
  holidayType="play-and-watch"
  matchingEvents={matchingEvents}
  similarHolidays={similarHolidays}
  slug={slug}
/>

